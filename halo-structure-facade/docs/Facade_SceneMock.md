# 设计模式概述

## 外观模式描述
`外观模式` 也叫做门面模式，是一种结构型设计模式，主要解决的是 `降低调用方使用接口的复杂逻辑组合`。这样实际的接口提供方会提供一个中间层，用于包装逻辑提供API接口供调用方调用。  
有些时候外观模式也被⽤在中间件层，对服务中的通用性复杂逻辑进行中间件层包装，让使用方可以只关心业务开发。

## 与其他设计模式的关系：

1. [外观]()为现有对象定义了一个新接口，[适配器]()则会运用已有的接口。[适配器]()通常只封装一个对象，[外观]()通常会作用于整个对象子系统上。
2. 当只需要对客户端代码隐藏子系统创建对象的方式时，你可以使用[抽象工厂]()来代替[外观]()。
3. [享元]()展示了如何生成大量的小型对象，[外观]()则展示了如何用一个对象来代替整个子系统。
4. [外观]() 和 [中介者]()的职责类似：它们都尝试在大量紧密耦合的类中组织起合作。
   - `外观`为子系统中的多有对象定义了一个简单的接口，但是它不提供任何新功能。子系统本身不会意识到外观的存在。子系统中的对象可以直接进行交流。
   - `中介者`将系统中组件的沟通行为中心化。各组件只知道中介者对象，无法直接相互交流。
5. [外观]()类通常可以转换成单例类，因为在大部分情况下一个外观对象就足够了。
6. [外观]()与[代理]()的相似之处在于它们都缓存了一个复杂实体并自己对其进行初始化。`代理`与其服务对象遵循同一接口，是的自己和服务对象可以互换，在这一点上他与`外观`不同。


## 业务场景
这里我们来在现有服务基础上，模拟一个将所有服务接口添加白名单的业务场景。

- 涉及到切面编程
- 将复杂或者多个接口包装统一对外提供服务
- 当然可以用在中间层中，让服务变的可以同意控制。（推荐）

## 模块含义
*-00：代表模拟的场景（使用设计模式前后公用的类）；  
*-01：传统业务逻辑实现（非设计模式实现）；  
*-02：通过设计模式优化重构后，业务逻辑的实现。
